# 《信道编码系统仿真设计与性能分析报告》（终极防御版）

## 第一章 绪论：系统建模与仿真可信度

### 1.1 项目背景与设计目标

***背景** ：通信系统在噪声信道下的可靠性需求，纠错编码（ECC）的核心地位。

***目标** ：构建基于 AWGN 信道的全链路仿真系统，实现卷积码与 Turbo 码的编成与译码，验证 Turbo 码逼近香农极限（Shannon Limit）的性能。

### 1.2 系统总体架构与模块化设计

***数据流管道** ：信源生成 (**$u$**) **$\rightarrow$** 编码 (**$c$**) **$\rightarrow$** BPSK调制 (**$x$**) **$\rightarrow$** AWGN信道 (**$y=x+n$**) **$\rightarrow$** 解调/译码 (**$\hat{u}$**) **$\rightarrow$** 误码统计。

***代码实现架构** ：

***控制中心** ：`include/config.h` 中的 `DECODER_TYPE` 宏定义（实现 4 种模式切换）。

***主控逻辑** ：`src/main.c` 中的 `run_cc_simulation` 和 `run_turbo_simulation` 函数。

***仿真可信度设计（防御重点）** ：

***蒙特卡洛准则** ：阐述 `seq_num` (帧数) 的设定依据。在高 SNR (**$10^{-5}$** BER) 下，必须仿真足够多的帧以捕获至少 100 个错误比特，保证统计置信度。

***随机性保障** ：`srand(time(0))` 的使用及其在当前仿真规模下的适用性分析。

### 1.3 仿真可信度设计

蒙特卡洛仿真准则：

理论：解释为何要在目标误码率（如 $10^{-5}$）下至少收集 100 个错误比特（置信度与方差分析）。

代码对应：run_turbo_simulation 中的 seq_num 设置策略，以及为何在高 SNR 下需要跑更多的帧。

随机数发生器质量：

拷问预警：“C语言自带的 rand() 周期短，会不会影响 Turbo 码长序列的仿真？”防御：承认 rand() 的局限性，但指出在本课程设计规模下（帧长1024），通过 srand(time(0)) 重新播种已能满足基本统计特性需求。

---

## 第二章 信道环境与基础模块建模

### 2.1 BPSK 调制与 LLR 接口

***数学模型** ：**$0\to +1, 1\to -1$**。

***代码映射** ：`src/convolutional_code.c` 中的 `modulation()`。

***关键细节** ：

***LLR 符号一致性** ：强调调制映射必须与 LLR 计算公式 **$L_c = \frac{4E_s}{N_0}y$** 的符号逻辑一致，否则会导致译码器正反馈发散。

### 2.2 AWGN 信道建模与 SNR 定标

***噪声生成算法** ：

***原理** ：Box-Muller 变换，将均匀分布 **$U(0,1)$** 映射为正态分布 **$N(0,1)$**。

***代码防御** ：`src/convolutional_code.c` 中 `channel()` 函数对 `log(0)` 边界情况的保护 (`u=0.999999`)。

***信噪比 (SNR) 定标自检（重中之重）** ：

***拷问预案** ：*“如何证明代码中的 SNR 是准确的？”*

* 自证逻辑：展示 N0 计算公式的推导链条：

  $$
  E_s = R \cdot E_b
  $$

  $$
  \sigma^2 = \frac{N_0}{2} = \frac{1}{2R} \cdot10^{-\frac{SNR_{dB}}{10}}
  $$

  （代码中 1.0/code_rate 精确对应 $1/R$，确保了不同码率下的公平对比）。

### 2.3 浮点数精度处理

细节：解释为何在信道加噪时使用 double 而非 float，以及 Box-Muller 变换中 log 函数对输入域的保护（防止 log(0)）。

---

## 第三章 核心模块一：卷积码编码与 Viterbi 译码算法

*本章重点：展示对“网格图（Trellis）”物理本质的理解及 Viterbi 的动态规划实现。*

### 3.1 (7, 5) 卷积码编码器建模

***数学模型** ：

* 生成多项式：**$G_1(D)=1+D+D^2$** (八进制7), **$G_2(D)=1+D^2$** (八进制5)。
* 约束长度 **$K=3$**，记忆深度 **$m=2$**。

***代码映射** ：

*`src/convolutional_code.c` 中的 `encoder()`：利用位运算 (`^`) 和变量 `s0, s1` 模拟移位寄存器。

***Trellis 构建** ：`src/trellis.c` 中的 `stateTable` 采用查表法硬编码，与多项式逻辑一一对应。

***工程细节：补零 (Zero Padding)** ：

* 在 `src/main.c` 中设置 `CC_message_length` 包含尾比特，强迫编码器回归全零状态 (Trellis Termination)，为译码提供确定的终态。

### 3.2 Viterbi 译码算法原理与工程实现

***核心思想** ：最大似然序列估计 (MLSE)，在网格图上寻找累积度量最小路径。

***分支度量 (BMU)** ：

***硬判决** (`hardDecoder`)：汉明距离。

***软判决** (`softDecode`)：欧氏距离平方。

**防御点* ：解释软判决保留了信道可靠性信息，为何能带来约 2-3dB 的增益。

***加-比-选 (ACS) 与 幸存路径存储** ：

***代码逻辑** ：`src/viterbi.c` 中 `path1d` vs `path2d` 的比较。

***存储策略** ：`trellisTable` 存储的是 **幸存路径的来源边 ID** ，而非简单的状态，这简化了回溯时的输入比特判定。

***回溯 (Traceback) 策略** ：

* 利用编码端的补零操作，强制从 **$T$** 时刻的**状态 0** 开始回溯 (`pathTable[T][0]`)，而非寻找最小值，提高了译码可靠性。

路径度量的动态范围管理（新增）：

问题：在连续流传输中，路径度量会无限增加导致溢出。

工程解法：虽然本项目是分帧仿真（每帧复位），但在工程上通常采用“度量归一化（Metric Normalization）”或“模运算”来解决。

代码体现：在本项目中，因为帧长有限且使用了 double，暂时不需要此处理，但在报告中提及表明你有工程视野

---

## 第四章 核心模块二：SISO 译码算法（从 BCJR 到 Log-MAP）

*本章重点：展示对数值稳定性、计算复杂度及算法演进的深刻理解。*

### 4.1 BCJR 算法：概率域实现的局限

***原理** ：前向-后向递归计算后验概率 (APP)。

***工程痛点** ：概率连乘导致 **浮点数下溢 (Underflow)** 。

***代码分析** ：`src/bcjr.c` 中虽然加入了归一化补救措施，但在长帧或高 SNR 下仍不稳定，引出 Log-MAP 的必要性。

### 4.2 Log-MAP 算法：数值稳定的工程优选

***数学建模：Max-Log 算子**

* 核心变换：**$\ln(e^a + e^b) = \max(a, b) + \ln(1 + e^{-|a-b|})$**。

***代码实现映射 (`src/log_map_decoder.c`)** ：

***Jacobian 函数 (`jac_log`)** ：实现了 **$\max^*$** 运算。

***优化 Trick** ：`if (diff > 10.0) return a;` —— 当差值过大时忽略校正项，平衡精度与速度。

***关键工程细节（高频考点）** ：

***数值归一化 (Normalization)** ：代码中 `log_alpha[t][s] -= log_alpha[t][0]`。解释其作用是防止 Log 域数值累加导致 `double` 溢出。

***Beta 的非归零初始化** ：

* *现象* ：`log_beta` 初始化为 `LOG_ONE` (全0，等概率)。
* *原因* ：Turbo 码的 RSC 编码器通常未做完全归零，译码器反向递归时必须假设结束状态未知（等概率），而非强行设为状态 0。

### 4.3 算法验证策略

退化验证：将 Turbo 码的迭代次数设为 0 或将交织器设为直通，检查 Log-MAP 输出的硬判决结果是否与 Viterbi 译码器一致（理论上 MAP 性能应略优于或等于 ML）。

Max-Log-MAP 近似验证：将 jac_log 中的校正项去掉（只保留 max），观察性能是否下降约 0.5dB，以此反证 jac_log 的校正项生效了。

---

## 第五章 核心模块三：Turbo 码系统设计与迭代译码

*本章重点：系统级交互逻辑、正反馈机制与特殊工程处理。*

### 5.1 PCCC 编码器架构

***RSC (递归系统卷积码) 的必要性** ：

**原理* ：产生无限冲击响应 (IIR)，结合交织器实现频谱细化 (Spectral Thinning)，获得交织增益。

**代码* ：`src/turbo_code.c` 中的 `component_rsc_encoder` (反馈逻辑 `f = m^s0^s1`)。

***交织器设计** ：`turbo_generate_interleaver` (随机洗牌) 及其对相关性的破坏作用。

### 5.2 Turbo 迭代译码流程 (Turbo Principle)

***信息交换机制** ：

***外在信息 (**$L_e$**)** ：**$L_e = L_{all} - L_c - L_a$**。

* 代码逻辑：turbo_decoder_wrapper 中 DEC1 与 DEC2 的交互闭环：

  DEC1 $\to$ Interleave $\to$ DEC2 $\to$ De-interleave $\to$ DEC1。

  强调必须减去输入的先验信息，避免正反馈震荡。

***关键工程 Trick：尾比特的软终止 (Soft Termination)**

  ***代码位置** ：`turbo_decoder_wrapper` 中的 `Lc_sys[i] = rx_llr + 500.0`。

  ***原理剖析** ：虽然物理上没有发送归零比特，但在仿真中尾部补了 0。通过人为赋予尾比特极大的 LLR（强先验），强行引导译码器向正确状态收敛，是降低 Error Floor 的关键手段。

5.2.1 交织器设计的深度讨论（新增）

理论：交织器不仅是“乱序”，更是为了制造“长码”和“相关性白化”。

代码分析：turbo_generate_interleaver 使用的随机洗牌算法。

拷问预警：“随机交织是最好的吗？”（答：不是。对于短帧，S-Random 交织器通常更好，因为它保证了相邻比特在交织后仍然保持一定距离。本项目为了通用性使用了随机交织）。

5.3 迭代停止准则（新增）

当前实现：固定迭代次数 (TURBO_ITERATIONS = 8)。

扩展思考：提及 CRC 辅助停止 或 SCR (Sign Change Ratio) 等动态停止准则，展示对降低功耗/时延的工程思考。

---

## 第六章 仿真结果分析与总结

### 6.1 性能对比分析

***瀑布区 (Waterfall)** ：展示 Turbo 码在低 SNR 下陡峭的误码率下降曲线。

***算法对比** ：硬判决 Viterbi vs. 软判决 Viterbi (约 2dB 增益) vs. Turbo (逼近容量)。

### 6.2 错误平层 (Error Floor) 的深度剖析

***现象** ：高 SNR 下 Turbo 码 BER 曲线变平。

***成因** ：由 Turbo 码的最小自由距离 (**$d_{free, eff}$**) 决定。解释 RSC 结构如何改善这一点但无法完全消除。虽然交织器增大了平均码距，但仍存在少量低重码字（特别是输入序列重量为 2 时）。

代码关联：解释为何 PCCC 结构（特别是 RSC 反馈）能改善这一点，但无法根除。

### 6.3 复杂度与性能权衡

***运算量** ：Log-MAP (多次 `max*`, 前后向遍历) >> Viterbi (简单加比选)。

***迭代次数** ：分析 `TURBO_ITERATIONS=8` 的合理性（性能饱和点 vs. 时延）。

Viterbi: 主要是加法和比较。

Log-MAP: 包含 exp, log (查表)，且每个比特需要前向、后向两次遍历，计算量约为 Viterbi 的 3-4 倍。

存储开销：Log-MAP 需要存储整个帧长的 $\alpha, \beta, \gamma$ 数组，空间复杂度为 $O(FrameLen \times States)$，而 Viterbi 只需要存储回溯路径。

### 6.4 总结与心得

* 从理论公式到 C 语言实现的跨越：对“信道编码定理”的深刻理解，以及对“数值稳定性”等工程问题的敬畏。

---

## 附录

***A. 关键代码索引** ：核心算法函数与源文件对应表。

***B. 数学-代码对照表** ：

* 公式 **$\alpha_t(s) = \sum\alpha_{t-1} \gamma$****$\longleftrightarrow$** 代码 `log_alpha[t][s] = jac_log(...)`。
* 公式 **$L_c = \frac{4E_s}{N_0}y$****$\longleftrightarrow$** 代码 `Lc_factor = 4.0 / N0`。
